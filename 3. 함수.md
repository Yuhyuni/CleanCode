## 목차 ##
- [작게 만들어라](#1)
- [한가지만 해라](#2)
- [함수 당 추상화 수준은 하나로 하라](#3)
- [switch 문](#4)
- [서술적인 이름을 사용하라](#5)
- [함수 인수](#6)
- [부수 효과를 일으키지 마라](#7)
- [명령과 조회를 분리하라](#8)
- [요류 코드보다 예외를 사용하라](#9)
- [반복하지 마라](#10)
- [구조적 프로그래밍](#11)
- [함수를 어떻게 짜죠?](#12)
- [결론](#13)
- [과제](#14)

---

> 어떤 프로그램이든 가장 기본적인 단위가 함수다. 이 장은 함수를 잘 만드는 법을 소개한다.

<a name="1"></a>
## 작게 만들어라 ##
- 각 함수가 명백하고 하나의 이야기를 표현해야 한다.
- 블록과 들여쓰기
  - if / else / while 문 등에 들어가는 블록은 한 줄이어야 한다.
  - 블록 내에서 호출하는 함수 이름을 적절히 짓는다면 이해하기 쉽다.
  - 들여쓰기 수준은 2단을 넘으면 안된다.
```
// p.42 3-2

public static String renderPageWithSetupsAndTeardowns(PageData pageData, boolean isSuite) throws Exception {
  boolean isTestPage = pageData.hasAttribute("Test");
  if (isTestPage) {
    WikiPage testPage = pageData.getWikiPage();
    StringBuffer newPageContent = new StringBuffer();
    newPageContent.append(pageData.getContent());
    includeTeardownpages(testPage, newPageContent, isSuite);
    pageData.setContent(newPageContent.toString());
  }
  return pageData.getHtml();
}
```
```
// p.43 3-3
  
public static String renderPageWithSetupsAndTeardowns(PageData pageData, boolean isSuite) throws Exception {
  if (isTestPage(pageData)
    includeSetupAndTeardownPages(pageData, isSuite);
  return pageData.getHtml();
}
```

<a name="2"></a>
## 한가지만 해라 ##
> 함수는 한가지를 해야한다. 그 한가지를 잘해야 한다. 그 한가지만을 해야한다.
- 지정된 함수 이름 아래에서 추상화 수준이 하나인 단계만 수행
- 의미있는 이름으로 다른 함수를 추출할 수 있다면 여러 작업을 하는 것
- 한가지 작업만 하는 함수는 자연스럽게 섹션을 나누기 어려움

<a name="3"></a>
## 함수 당 추상화 수준은 하나로 하라 ##
- 함수가 확실히 한가지 작업만 하려면 함수 내 모든 문장의 추상화 수준이 동일 해야 한다.
  - 추상화 수준이 높다 : 디테일 부분을 많이 숨겼다는 의미
- 한 함수 내에 추상화 수준을 섞으면 코드를 읽는 사람이 헷갈린다.
  - 특정 표현이 근본 개념인지 세부사항인지 구분하기 어려운 탓이다.
  - 근본 개념과 세부사항을 뒤섞기 시작하면 사람들이 함수에 세부사항을 더 추가한다.
- 내려가기 규칙
  - 위에서 아래로 프로그램을 읽으면 함수 추상화 수준이 한 번에 한 단계씩 낮아진다.

<a name="4"></a>
## switch 문 ##
- switch 문은 작게 만들기 어렵고 한가지 작업만 하도록 만들기도 어렵다.
- `Polymorphism`을 이용하면 switch 문을 저차원 클래스에 숨기고 반복하지 않을 수 있다.
  - Abstract Factory에 숨기고 Factory는 switch 문을 사용해 적절한 파생 클래스의 인스턴스를 생성
```
// p.47 3-4

public Money calculatePay(Employee e) throws InvalidEmployeeType {
  switch (e.type) {
    case COMMISSIONED: return calculateCommissionedPay(e);
    case HOURLY: return calculateHourlyPay(e);
    case SALARIED: return calculateSalariedPay(e);
    default: throw new InvalidEmployeeType(e.type);
  }
}
```
- 위 함수의 문제점
  -  길고 한 가지 작업만 수행하지 않는다.
  -  SRP와 OCP를 위반
  -  위 함수와 구조가 동일한 함수를 무한정 양산한다. isPayday(Employee e, Date date), deliverPay(Employee e, Money pay) ...
```
// p.48-49 3-5

public abstract class Employee {
  public abstract boolean isPayday();
  public abstract Money calculatePay();
  public abstract void deliverPay(Money pay);
}

public class EmployeeFactory {
  public Employee makeEmployee(EmployeeRecord r) throws InvalidEmployeeType {
    switch (r.type) {
      case COMMISSIONED: return new CommissionedEmployee(r);
      case HOURLY: return new HourlyEmployee(r);
      case SALARIED: return new SalariedEmployee(r);
      default: throw new InvalidEmployeeType(e.type);
    }
  }
}
```

<a name="5"></a>
## 서술적인 이름을 사용하라 ##

<a name="6"></a>
## 함수 인수 ##

<a name="7"></a>
## 부수 효과를 일으키지 마라 ##

<a name="8"></a>
## 명령과 조회를 분리하라 ##

<a name="9"></a>
## 요류 코드보다 예외를 사용하라 ##

<a name="10"></a>
## 반복하지 마라 ##

<a name="11"></a>
## 구조적 프로그래밍 ##

<a name="12"></a>
## 함수를 어떻게 짜죠? ##

<a name="13"></a>
## 결론 ##

<a name="14"></a>
## 과제 ##
